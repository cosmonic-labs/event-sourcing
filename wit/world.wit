package cosmonic:eventsourcing@0.0.1;

/// Business logic
interface command-handler {
    use types.{event, command, state};

    /// Serialize, marshal, or encode a single event to its byte representation. This is the storage
    /// format for the event. The same technique used to deserialize should be used to serialize.
    serialize-event: func(event: event) -> result<list<u8>, string>;

    /// Deserialize, unmarshal, or decode a single event from its byte representation. This is the storage
    /// format for the event. The same technique used to deserialize should be used to serialize.
    deserialize-event: func(event: list<u8>) -> result<event, string>;

    /// Serialize, marshal, or encode a single command to its byte representation.
    /// The same technique used to deserialize should be used to serialize.
    serialize-command: func(command: command) -> result<list<u8>, string>;

    /// Deserialize, unmarshal, or decode a single command from its byte representation.
    /// The same technique used to deserialize should be used to serialize.
    deserialize-command: func(event: list<u8>) -> result<command, string>;

    /// Serialize, marshal, or encode the command-handler state to its byte representation.
    /// The same technique used to deserialize should be used to serialize.
    serialize-state: func(state: state) -> result<list<u8>, string>;

    /// Deserialize, unmarshal, or decode the command-handler state from its byte representation.
    /// The same technique used to deserialize should be used to serialize.
    deserialize-state: func(state: list<u8>) -> result<state, string>;

    /// Rehydrate or reconstruct this command-handler's state from a list of events, starting from the initial state.
    rehydrate: func(events: list<event>) -> result<state, string>;

    /// Using the given state, handle the command by returning applicable events.
    handle: func(state: state, command: command) -> result<list<event>, string>;
}

/// Handle events, emitting new commands if necessary
interface event-handler {
    use types.{event, command};

    /// Serialize, marshal, or encode a single event to its byte representation. This is the storage
    /// format for the event. The same technique used to deserialize should be used to serialize.
    serialize-event: func(event: event) -> result<list<u8>, string>;

    /// Deserialize, unmarshal, or decode a single event from its byte representation. This is the storage
    /// format for the event. The same technique used to deserialize should be used to serialize.
    deserialize-event: func(event: list<u8>) -> result<event, string>;

    /// Serialize, marshal, or encode a single command to its byte representation.
    /// The same technique used to deserialize should be used to serialize.
    serialize-command: func(command: command) -> result<list<u8>, string>;

    /// Deserialize, unmarshal, or decode a single command from its byte representation.
    /// The same technique used to deserialize should be used to serialize.
    deserialize-command: func(event: list<u8>) -> result<command, string>;

    /// Handle the event and return new commands to be emitted
    handle: func(event: event) -> result<list<command>, string>;
}

/// Handle events, updating the state
interface projector {
    use types.{event, state};

    /// Serialize, marshal, or encode a single event to its byte representation. This is the storage
    /// format for the event. The same technique used to deserialize should be used to serialize.
    serialize-event: func(event: event) -> result<list<u8>, string>;

    /// Deserialize, unmarshal, or decode a single event from its byte representation. This is the storage
    /// format for the event. The same technique used to deserialize should be used to serialize.
    deserialize-event: func(event: list<u8>) -> result<event, string>;

    /// Serialize, marshal, or encode the command-handler state to its byte representation.
    /// The same technique used to deserialize should be used to serialize.
    serialize-state: func(state: state) -> result<list<u8>, string>;

    /// Deserialize, unmarshal, or decode the command-handler state from its byte representation.
    /// The same technique used to deserialize should be used to serialize.
    deserialize-state: func(state: list<u8>) -> result<state, string>;

    /// Using the given state, handle the event and return the new state.
    handle: func(state: state, event: event) -> result<state, string>;
}

/// Main handler component of the entire system
interface event-sourcer {
    use types.{event, command};

    append: func(command-handler-id: string, events: list<event>) -> result<list<list<u8>>, string>;
    get-events: func(command-handler-id: string) -> result<list<event>, string>;
    handle-command: func(command-handler-id: string, command: list<u8>) -> result<list<event>, string>;
}

/// Persistent storage layer
interface event-store {
    use types.{event};

    // TODO: consider additional metadata
    append-event: func(command-handler-id: string, event: list<u8>) -> result<_, string>;
    get-events: func(command-handler-id: string) -> result<list<list<u8>>, string>;
}

/// Defines the core resources used in event sourcing patterns.
/// 
interface types {
    /// Represents an action or intent to change state, typically issued by a client.
    resource command;
    /// Represents a state change that has occurred as a result of processing a command.
    resource event;
    /// Represents the current state of an entity, reconstructed from a sequence of events.
    resource state;
}

/// Business logic component
world command-handler-w {
    export types;
    export command-handler;
}

world http-api-gateway-w {
    import event-sourcer;

    export wasi:http/incoming-handler@0.2.0;
}

/// Implementation of the event sourced system, aka platform harness
world event-sourcer-w {
    import command-handler;
    import event-store;

    export event-sourcer;
}

/// Implementation of the event sourced storage layer
world event-store-w {
    export event-store;
}